1.max_heap.cpp

利用一個max heap來解決這個問題，利用vector以便於動態存取，其中所需要的function為push,pop跟swap

先講程式的主要架構:
利用一個while迴圈來做指定的次數，
並在開頭把sum=0,跟heap.resize(1,0)來把結果跟heap做初始化
之後輸入M跟N，
並利用while迴圈把M個數據的空座位利用push放進heap裡面
再來利用while迴圈把N個粉絲的售票價錢存起來，利用pop來把最大丟出來
其中要注意的是，該排被買走的位置，空座位會少一個，
所以要放回去時要把該排空座位數-1再push回去heap中
最後再把算完的sum print出來就完成了

各個函式實作

push:
把要放進去heap的node利用push_back放入，接著利用.size-1確認其位置
而放進去的node不一定會符合max heap的規定，所以要做調整，
利用while迴圈，而條件為還沒到root跟parent比node大時
做往上調整的動作，利用swap交換完兩個點後，往上一個node走
直到root或者已經不需要調整的時候就結束了

pop:
首先先確認是否為空的，如果是空的就結束程式
而因為pop出的為root，所以先建立parent=1,lchild=2,rchild=3
之後利用output先暫時存放要return的值，並開始為這個heap進行調整
先把heap的尾端放進root中在對其往下調整，並把heap尾端delete掉
利用while(1)持續執行
先利用temp存parent的值
在確認兩件事情，左子有沒有在heap中，左子有沒有比parent大，
如果有的話把temp設定為左子，右子亦然
在檢查看看temp有沒有變
如果有變就跟變得那個node交換位置，並且往那邊移動
如果沒變的話就代表都可以了，就break

swap:
放入兩個值，並且做交換

2.height_union.cpp

首先先依照作業的要求比較weightUnion跟heightUnion，
我認為是heightUnion比較好，因為在利用heightUnion時才能真正依照樹高來決定哪一個要當根
才能夠達到Union後，一定能得到較矮樹的辦法，在collapsingFind中，才能做比較少次的traversed跟reset
而weightUnion無法真正的反應樹高，導致了有可能Union出比較高的樹，使得collapsingFind要花費較多時間

而程式中利用array來存樹的點，其中有主要的函式collapsingFind跟heightUnion

先講程式的主要架構:
利用變數來存有多少個tree要被輸入，再來利用while迴圈跑相對應的次數
而之中利用變數存有多少個node會被輸入，再來利用while迴圈跑相對應的次數
並當中輸入點的位置跟其parent，並把該點指向其parent，就結束了資料的輸入了
在來用三個功能 stop find 跟 union，利用char陣列來存輸入這些的字，並利用while迴圈讀取
利用strcmp來看是甚麼指令被輸入
如果輸入的是FIND，就cin要Find的值，並利用collapsingFind找到結果後，先暫時存進要output的vector中
如果輸入的是UNION，就cin兩個要union的root編號，並利用heightUnion來做Union
如果輸入的是STOP，就輸出存在vector中的結果，並且break，程式到此結束。

各個函式實作

collapsingFind:
宣告三個變數root,trail,lead以便移動，跟宣告一個變數count=0儲存move的次數
之後先做traversed，利用for迴圈，如果值還大於等於0的話，代表那不是root往那個方向繼續找，直到找到root
其中利用count++來存做了幾個move
接下來做reset的動作，為了之後更快速的查找
for迴圈中當他不是root的話就進入迴圈，並找完之後繼續往上移動
在當中利用if (root == a[trail])就break來避免多餘的reset，因為這個情況已經指向root就不必reset了
而如果還不是root的話，就把root成為其節點所指的對象，並利用lead繼續往上
其中也要利用count++來存做了幾個move
結束後return count讓output知道這次的find做了幾次的move

heightUnion:
傳入兩個樹根的index
並比較它們兩個的值，
如果i比較矮的話就讓j成為他的根
而其他情況就讓i成為j的根
其中特別注意的是如果樹高一樣的話，連上去後樹高會增加1，要做--的動作

